// Code generated by mockery v2.40.1. DO NOT EDIT.

package repository_mocks

import (
	entity "shop-service/internal/entity"

	mock "github.com/stretchr/testify/mock"

	gorm "gorm.io/gorm"
)

// ShopRepositoryMock is an autogenerated mock type for the ShopRepositoryInterface type
type ShopRepositoryMock struct {
	mock.Mock
}

// Create provides a mock function with given fields: db, shop
func (_m *ShopRepositoryMock) Create(db *gorm.DB, shop *entity.Shop) error {
	ret := _m.Called(db, shop)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, *entity.Shop) error); ok {
		r0 = rf(db, shop)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: db, id
func (_m *ShopRepositoryMock) Delete(db *gorm.DB, id uint) error {
	ret := _m.Called(db, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) error); ok {
		r0 = rf(db, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindAll provides a mock function with given fields: db, page, pageSize, searchTerm, includeInactive
func (_m *ShopRepositoryMock) FindAll(db *gorm.DB, page int, pageSize int, searchTerm string, includeInactive bool) ([]entity.Shop, int64, error) {
	ret := _m.Called(db, page, pageSize, searchTerm, includeInactive)

	var r0 []entity.Shop
	var r1 int64
	var r2 error

	if rf, ok := ret.Get(0).(func(*gorm.DB, int, int, string, bool) []entity.Shop); ok {
		r0 = rf(db, page, pageSize, searchTerm, includeInactive)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]entity.Shop)
		}
	}

	if rf, ok := ret.Get(1).(func(*gorm.DB, int, int, string, bool) int64); ok {
		r1 = rf(db, page, pageSize, searchTerm, includeInactive)
	} else {
		r1 = ret.Get(1).(int64)
	}

	if rf, ok := ret.Get(2).(func(*gorm.DB, int, int, string, bool) error); ok {
		r2 = rf(db, page, pageSize, searchTerm, includeInactive)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// FindByID provides a mock function with given fields: db, id
func (_m *ShopRepositoryMock) FindByID(db *gorm.DB, id uint) (*entity.Shop, error) {
	ret := _m.Called(db, id)

	var r0 *entity.Shop
	var r1 error

	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) *entity.Shop); ok {
		r0 = rf(db, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Shop)
		}
	}

	if rf, ok := ret.Get(1).(func(*gorm.DB, uint) error); ok {
		r1 = rf(db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindByIDWithWarehouses provides a mock function with given fields: db, id
func (_m *ShopRepositoryMock) FindByIDWithWarehouses(db *gorm.DB, id uint) (*entity.Shop, error) {
	ret := _m.Called(db, id)

	var r0 *entity.Shop
	var r1 error

	if rf, ok := ret.Get(0).(func(*gorm.DB, uint) *entity.Shop); ok {
		r0 = rf(db, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.Shop)
		}
	}

	if rf, ok := ret.Get(1).(func(*gorm.DB, uint) error); ok {
		r1 = rf(db, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: db, shop
func (_m *ShopRepositoryMock) Update(db *gorm.DB, shop *entity.Shop) error {
	ret := _m.Called(db, shop)

	var r0 error
	if rf, ok := ret.Get(0).(func(*gorm.DB, *entity.Shop) error); ok {
		r0 = rf(db, shop)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewShopRepositoryMock creates a new instance of ShopRepositoryMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewShopRepositoryMock() *ShopRepositoryMock {
	mock := &ShopRepositoryMock{}
	return mock
}